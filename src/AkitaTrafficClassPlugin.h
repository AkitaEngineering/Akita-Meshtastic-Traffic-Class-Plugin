#pragma once

#include "meshtastic.h" // Main Meshtastic header
#include "Plugin.h"     // Base Plugin class
#include "MeshInterface.h" // For _meshInterface
#include "mesh/ProtobufModule.h" // For inheriting from ProtobufModule

// This is the header file generated by nanopb from your akita_plugin.proto
// Ensure this path is correct based on your Meshtastic build environment.
// It might be something like "akita_plugin.pb.h" or "meshtastic/akita_plugin.pb.h"
#include "akita_plugin.pb.h"

// Potentially needed Meshtastic headers for API calls
#include "NodeDB.h"         // For accessing node information
#include "RadioInterface.h" // For radio-specific metrics like channel utilization
#include "PowerFSM.h"       // For battery level (actual class name might vary)
// NVS utilities might be part of a general storage or config header
#include "NVSStorage.h"     // Assuming a class/namespace for NVS operations


#include <map>
#include <queue>
#include <vector>
#include <string>
#include <chrono>
#include <random>
#include <algorithm> // For std::min, std::max
#include <numeric>   // For std::accumulate
#include <functional> // For std::function (callback)


// Forward declaration
class MeshInterface;

// Maximum number of parity bytes for FEC simulation
#define FEC_MAX_PARITY_BYTES 16
// Limits on concurrent fragmentation sessions to prevent resource exhaustion
#define MAX_INCOMING_SESSIONS 20
#define MAX_OUTGOING_SESSIONS 20
// Minimum practical payload size for a fragment after overheads
#define MIN_MTU_FUDGE 20 // Minimum bytes allowed for actual user data in a fragment


namespace meshtastic {

// Define a unique PortNum for the Akita Traffic Class Plugin.
const uint8_t PortNum_AKITA_TRAFFIC_CLASS_APP = PortNum_PRIVATE_APP + 1; // Example, ensure uniqueness

// FEC Status Enum
enum FEC_Status {
    FEC_OK,             // Data is okay, no correction needed
    FEC_CORRECTED,      // Data was corrupted but successfully corrected
    FEC_FAILED,         // Data is corrupted and could not be corrected
    FEC_NOT_APPLICABLE  // FEC was not applied to this packet/fragment
};

/**
 * @brief Holds the configuration parameters for a single traffic class.
 */
struct TrafficClassConfig {
    int priority = 3; ///< Priority level (higher value = higher priority). Default 3.
    bool reliable = false; ///< Enable ACK/retransmission reliability. Default false.
    bool encrypted = false; ///< Enable payload encryption (requires crypto library). Default false.
    int maxFragmentSize = 180; ///< Max bytes per LoRa payload chunk (adjust based on LoRa settings and overhead). Default 180.
    int retries = 3; ///< Max retransmission attempts for reliable fragments. Default 3.
    uint8_t fec_num_parity_bytes = 0; ///< Number of FEC parity bytes to generate (0 = no FEC, max FEC_MAX_PARITY_BYTES). Default 0.
    int congestionWindow = 5; ///< Initial/current congestion window size for reliable traffic. Default 5.
    uint8_t encryptionKey = 123; ///< Key byte used for placeholder encryption derivation. Default 123.
    uint32_t trafficClassId = 0; ///< The ID of this traffic class. Set during configuration.
};

/**
 * @brief Tracks the state of an outgoing packet that has been fragmented.
 * Used for reliable transmission and retransmissions.
 */
struct OutgoingFragmentedPacket {
    uint32_t fragmentId; ///< Unique ID for this fragmented packet.
    std::vector<meshtastic_AkitaPluginEnvelope> fragments; ///< Holds the fully prepared fragment envelopes.
    int totalFragments; ///< Total number of fragments for this packet.
    std::map<uint32_t, bool> ackedFragmentStatus; ///< Tracks ACK status per fragment index (true if ACKed).
    int ackedFragmentsCount; ///< Number of fragments successfully ACKed.
    std::chrono::steady_clock::time_point lastSentTime; ///< Time the last fragment (or retransmission batch) was sent.
    int retryCount; ///< Number of retransmission attempts made.
    uint32_t destinationNodeNum; ///< Destination node ID for this packet.

    /** @brief Default constructor initializing members. */
    OutgoingFragmentedPacket() : fragmentId(0), totalFragments(0), ackedFragmentsCount(0), retryCount(0), destinationNodeNum(0), lastSentTime(std::chrono::steady_clock::time_point::min()) {}
};

/**
 * @brief Tracks the state of an incoming fragmented packet during reassembly.
 */
struct IncomingFragmentedPacket {
    uint32_t fragmentId; ///< Unique ID for this fragmented packet.
    
    /** @brief Information stored for each received fragment. */
    struct FragmentInfo {
        std::vector<uint8_t> raw_payload_chunk; ///< Payload chunk as received (potentially encrypted).
        std::vector<uint8_t> fec_data_chunk;    ///< FEC data as received.
        bool processed_successfully = false;    ///< True if FEC OK/Corrected & Decrypted successfully.
        std::vector<uint8_t> corrected_decrypted_payload; ///< Final processed data for this fragment.
        uint8_t fec_num_parity_bytes_expected = 0; ///< FEC setting expected based on TC config.
        bool encrypted_expected = false;           ///< Encryption setting expected based on TC config.
        uint8_t encryption_key_expected = 0;       ///< Key expected based on TC config.
    };
    std::map<uint32_t, FragmentInfo> receivedRawFragments; ///< Maps fragment_index to its received info.

    int totalFragments; ///< Expected total number of fragments.
    uint32_t originalMessageSize; ///< Original size of the full message before fragmentation.
    uint32_t trafficClassId;      ///< Traffic class ID associated with this packet.
    std::chrono::steady_clock::time_point lastFragmentReceivedTime; ///< Time the most recent fragment was received.
    uint32_t sourceNodeNum; ///< Node ID of the sender.

    /** @brief Default constructor initializing members. */
    IncomingFragmentedPacket() : 
        fragmentId(0), totalFragments(0), originalMessageSize(0), trafficClassId(0), sourceNodeNum(0), lastFragmentReceivedTime(std::chrono::steady_clock::time_point::min()) {}
};

/**
 * @brief Tracks QoS statistics for a single traffic class.
 */
struct TrafficClassQoSStats {
    uint32_t packetsSent = 0;      ///< Count of non-fragmented packets sent.
    uint32_t fragmentsSent = 0;    ///< Count of fragments sent (includes single-fragment reliable packets).
    uint32_t acksReceived = 0;     ///< Count of ACKs received for reliable fragments.
    uint32_t timeouts = 0;         ///< Count of retransmission timeouts where max retries were reached.
    uint32_t fecCorrected = 0;     ///< Count of received packets/fragments successfully corrected by FEC.
    uint32_t fecFailures = 0;      ///< Count of received packets/fragments where FEC check failed unrecoverably.
};


/**
 * @brief Akita Traffic Class Plugin implementing QoS, reliability, and fragmentation.
 * Inherits from ProtobufModule to handle packets on a specific PortNum.
 */
class AkitaTrafficClassPlugin : public ProtobufModule<meshtastic_AkitaPluginEnvelope> {
public:
    // --- Callback Type Definition ---
    /**
     * @brief Callback function type for delivering received application data.
     * @param fromNodeId The node ID of the sender.
     * @param trafficClassId The traffic class ID the data was received on.
     * @param data The reassembled, decrypted, and FEC-checked payload data.
     */
    using DataReceiveCallback = std::function<void(uint32_t fromNodeId, uint32_t trafficClassId, const std::vector<uint8_t>& data)>;

    // --- Constructor & Destructor ---
    /** @brief Constructor. */
    AkitaTrafficClassPlugin(MeshInterface& meshInterface);
    /** @brief Destructor. */
    virtual ~AkitaTrafficClassPlugin();

    // --- Core Meshtastic Overrides ---
    /** @brief Handles received protobuf messages on the plugin's PortNum. */
    virtual void handleReceivedProtobuf(meshtastic_AkitaPluginEnvelope &msg, const MeshPacket &meshPacket) override;
    /** @brief Periodic loop function called by the Meshtastic core. */
    virtual void loop() override;
    /** @brief Called for ANY packet received by the radio (passes to base class). */
    virtual void onPacketReceived(MeshPacket &packet) override; 
    /** @brief Called for ANY packet *before* it is sent (allows inspection/blocking). */
    virtual bool onPacketToSend(MeshPacket &packet, const NodeInfo* destination) override;   
    /** @brief Called when node information is updated in the NodeDB. */
    virtual void onNodeUpdated(NodeInfo &node) override;
    /** @brief Called when the main Meshtastic device configuration changes. */
    virtual void onConfigChanged() override; 
    /** @brief Called when the radio's power/operational state changes. */
    virtual void onRadioStateChanged(RadioState state) override; 

    // --- Configuration Methods ---
    /** @brief Configures or updates a specific traffic class. Persists to NVS. */
    bool configureTrafficClass(uint32_t trafficClassId, int priority, bool reliable, bool encrypted, 
                               int maxFragmentSize, int retries, uint8_t fec_num_parity_bytes, 
                               int congestionWindow, uint8_t encryptionKey);
    /** @brief Gets the configuration for a specific traffic class. */
    const TrafficClassConfig* getTrafficClassConfig(uint32_t trafficClassId);
    /** @brief Deletes a traffic class configuration from memory and NVS. */
    bool deleteTrafficClass(uint32_t trafficClassId);
    /** @brief Handles administrative commands intended for this plugin (conceptual). */
    bool handleAdminCommand(const std::string& command, const std::vector<std::string>& args);


    // --- Public API ---
    /** @brief Public method for applications to send data via this plugin. */
    bool sendData(const uint8_t *data, size_t size, uint32_t trafficClassId, uint32_t destinationNodeNum = BROADCAST_ADDR);
    /** @brief Registers a callback function to receive successfully processed data. */
    void registerDataHandler(DataReceiveCallback handler);

    // --- Static Registration Members ---
    // NOTE: Dynamic instantiation in MeshService::setupModules is preferred.
    static bool registered; ///< Static variable used for plugin registration attempt.

private:
    // --- Internal Data Structures ---
    std::map<uint32_t, TrafficClassConfig> trafficClasses; ///< Current configuration for each TC ID.
    std::map<uint32_t, TrafficClassConfig> defaultTrafficClassConfigs; ///< Loaded/default configs (base for dynamic adaptation).
    std::map<uint32_t, std::queue<meshtastic_AkitaPluginEnvelope>> transmitQueues; ///< Outgoing packet queues per TC ID.
    std::map<uint32_t, OutgoingFragmentedPacket> outgoingFragments; ///< Tracks state of outgoing fragmented packets by fragment ID.
    std::map<uint32_t, IncomingFragmentedPacket> incomingFragments; ///< Tracks state of incoming fragmented packets by combined key (sourceNode << 16 | fragId).
    std::map<uint32_t, TrafficClassQoSStats> qosStats; ///< QoS statistics per TC ID.
    std::map<uint32_t, int> routingBackoffCounts; ///< Tracks routing backoff level per node ID.

    // --- State Variables ---
    DataReceiveCallback onDataReceived = nullptr; ///< Registered callback for received application data.
    std::random_device rd; ///< Source for random number generation seed.
    std::mt19937 gen; ///< Mersenne Twister random number generator.
    RadioState currentRadioState; ///< Tracks the current radio power state.
    std::chrono::steady_clock::time_point lastQoSResetTime; ///< Timestamp for periodic QoS stat reset.
    uint32_t lastDequeuedTrafficClassId = 0; ///< Used for simple round-robin hint in queue servicing.


    // --- Private Helper Methods ---
    // Processing Incoming Data
    void processIncomingAkitaPayload(const meshtastic_AkitaPacketPayload &payload, const MeshPacket &meshPacket);
    void processIncomingAkitaControl(const meshtastic_AkitaControlMessage &controlMsg, const MeshPacket &meshPacket);
    void sendAckForFragment(uint32_t destinationNodeNum, uint32_t fragmentId, uint32_t fragmentIndex);
    void reassembleAndProcessPacket(uint32_t combinedKey); 

    // Processing Outgoing Data
    void handleFragmentation(const uint8_t *data, size_t size, uint32_t trafficClassId, uint32_t destinationNodeNum);
    void sendRawPluginPacket(meshtastic_AkitaPluginEnvelope &envelope, uint32_t destinationNodeNum, bool reliable);
    void serviceTransmitQueues();

    // Crypto & FEC
    bool applyPluginEncryption(std::vector<uint8_t>& data, uint8_t key_byte, const uint8_t* iv, bool encrypt);
    std::vector<uint8_t> applyFEC(const std::vector<uint8_t>& data_chunk, uint8_t num_parity_bytes);
    FEC_Status checkAndCorrectFEC(std::vector<uint8_t>& data_chunk, const std::vector<uint8_t>& received_fec_chunk);

    // Dynamic Adaptation & QoS
    void updateRoutingMetrics(const NodeInfo &node); 
    void adjustCongestionWindow(uint32_t trafficClassId, bool success); 
    void dynamicFragmentSizeAdjustment(uint32_t trafficClassId, float linkSnr); 
    void dynamicTrafficClassAdaptation(); 
    void monitorQoS(); 

    // Configuration Persistence
    void loadPluginConfig(); 
    void savePluginConfig(); // Note: Currently called implicitly by configure/delete methods
    void saveTrafficClassToNVS(const TrafficClassConfig& config);
    void deleteTrafficClassFromNVS(uint32_t trafficClassId);

    // Timers & Utility
    void checkReassemblyTimeouts();
    void checkRetransmissionTimeouts(); 
    int getDeviceBatteryLevel();
    float getLinkSnrToNode(uint32_t nodeId); 
    float getChannelUtilization();
    size_t getQueueLength(uint32_t trafficClassId);
    uint32_t generateFragmentId();
    
    // NVS Key constants
    const char* NVS_KEY_PREFIX = "akita_tc_"; ///< Prefix for NVS keys related to this plugin.
    const char* NVS_KEY_CLASS_COUNT = "akita_tc_count"; ///< NVS key for storing the number of configured classes.

};

} // namespace meshtastic
